Daily report
10/31
Hello :
    今天开始集中精力看FlexVolume,先看了opensds-k8s，又在github上搜索相关的资料查阅。
    1、opensds-k8s代码、文档
    2、aliyun-disk flex-volume相关代码 

11/1
Hello:
    今天开完会，感觉整个项目的任务还是比较重，由于自身能力的原因自己能做的比较有限，但是还是尽全力把自己的工作做好，为项目做贡献。
    根据任务的分配，主要研究k8s的安装，感觉过程都了解了，不过先要在自己电脑上实验一遍，再开始安装。
    1、k8s Centos 安装
    2、k8s Ubuntu 安装
11/2
hello:
今天，主要是实验K8s的单机安装，我主要找到三种方法：前两钟是在Kubernetes官网上的，第三种是参考新勇哥的博客。
1.Minikube在本地主机简单运行Kubernetes（https://kubernetes.io/docs/tutorials/stateless-application/hello-minikube/）
2.使用Ubuntu运行Kubernetes集群（https://kubernetes.io/docs/getting-started-guides/ubuntu/）
3.Kubernetes单机安装部署（http://www.cnblogs.com/edisonxiang/p/6911994.html）
1 安装Docker
1) apt-get update

2) apt-get upgrade

3) apt-get install docker.io

4) service docker restart

5) docker run hello-world

6) docker run -it ubuntu bash

 

2 安装Go
1) 下载Go语言压缩包
wget https://golang.org/dl/go1.8.3.linux-amd64.tar.gz
2) 解压压缩包
tar -C /usr/local -xzf go1.8.3.linux-amd64.tar.gz
3) 添加下列环境变量到/etc/profile(for a system-wide installation) or $HOME/.profile
export PATH=$PATH:/usr/local/go/bin
4) 编写hello.Go文件，填写下列内容，放到$HOME/go/src/hello文件夹中
package main
import "fmt"
func main() {
    fmt.Printf("hello, world\n")
}
5) 测试Go语言环境，$HOME/go/默认为/root/go/
go run ~/go/src/hello/hello.go
 
3 安装Etcd
1) 下载Etcd压缩包
wget https://github.com/coreos/etcd/releases/download/v3.1.8/etcd-v3.1.8-linux-amd64.tar.gz
2) 解压Etcd压缩包

tar -xzf etcd-v3.1.8-linux-amd64.tar.gz

3) 拷贝Etcd可执行程序

cd etcd-v3.1.8-linux-amd64

cp etcd etcdctl /usr/bin

 

4 安装Flannel
1) 下载Flannel压缩包
wget https://github.com/coreos/flannel/releases/download/v0.7.1/flannel-v0.7.1-linux-amd64.tar.gz
2) 解压Flannel压缩包

tar -xzf flannel-v0.7.1-linux-amd64.tar.gz

3) 拷贝Flannel可执行程序

cd flannel-v0.7.1-linux-amd64

cp flannelid mk-docker-opts.sh /usr/bin

 

5 安装K8S
1) 获取K8S Master版本(1.7.0-alpha)
git clone https://github.com/kubernetes/kubernetes.git
2) 编译K8S

cd kubernetes

make quick-release

编译完成后：

K8S Server文件：~/go/src/kubernetes/_output/release-stage/server/linux-amd64/kubernetes/server/bin

K8S Client文件： ~/go/src/kubernetes/_output/release-stage/client/linux-amd64/kubernetes/client/bin

3) 拷贝K8S Server和Client可执行文件

cd ~/go/src/kubernetes/_output/release-stage/server/linux-amd64/kubernetes/server/bin

cp * /usr/bin

cd ~/go/src/kubernetes/_output/release-stage/client/linux-amd64/kubernetes/client/bin

cp * /usr/bin

注： 下述操作中的10.229.43.237请替换为你安装K8S的主机的IP地址 

6 启动和测试Etcd
K8S使用Etcd保存Master和Node节点的信息，所以启动K8S之前需要先启动Etcd
1) 启动Etcd
etcd -initial-advertise-peer-urls http://10.229.43.237:2380 -listen-peer-urls http://10.229.43.237:2380 -listen-client-urls http://10.229.43.237:2379,http://127.0.0.1:2379 -advertise-client-urls http://10.229.43.237:2379 
2) 读写Etcd Key和Value
etcdctl set foo bar
etcdctl get foo

 

7 启动Flannel并关联Docker
1) 启动Flannel
flanneld
 
2) 设置Etcd配置Flannel
etcdctl set /coreos.com/network/config '{"Network":"172.17.0.0/16"}'
etcdctl set /coreos.com/network/subnets/172.17.10.0-24 '{"PublicIP":"10.229.43.237"}'
 
3) 设置Flannel关联Docker
mk-docker-opts.sh -i
source /run/flannel/subnet.env
rm /var/run/docker.pid
ifconfig docker0 ${FLANNEL_SUBNET}
service docker restart

  
8 启动K8S
1) 启动kube-apiserver
kube-apiserver --address=0.0.0.0  --insecure-port=8080 --service-cluster-ip-range='10.10.10.1/24' --log_dir=/usr/local/kubernete_test/logs/kube --kubelet_port=10250 --v=0 --logtostderr=false --etcd_servers=http://10.229.43.237:2379 --allow_privileged=false 
 
2) 启动kube-controller-manager
kube-controller-manager  --v=0 --logtostderr=false --log_dir=/usr/local/kubernete_test/logs/kube --master=10.229.43.237:8080
 
3) 启动kube-scheduler 
kube-scheduler  --master='10.229.43.237:8080' --v=0  --log_dir=/usr/local/kubernete_test/logs/kube
 
4) 测试master节点是否正常启动
kubectl get componentstatuses
 
5) 启动kube-proxy 
kube-proxy  --logtostderr=false --v=0 --master=http://10.229.43.237:8080
 
6) 启动kubelet  
kubelet  --logtostderr=false --v=0 --allow-privileged=false  --log_dir=/usr/local/kubernete_test/logs/kube  --address=0.0.0.0  --port=10250  --hostname_override=10.229.43.237  --api_servers=http://10.229.43.237:8080
 
7) 在Node上设置集群Context
kubectl config set-cluster test-cluster --server=http://10.229.43.237:8080
kubectl config set-context test-cluster --cluster=test-cluster
kubectl config use-context test-cluster 
 
8) 准备kubernetes/pause镜像
由于K8S Pod需要Pause镜像来启动Pause容器，所以需要准备kubernetes/pause镜像
docker pull docker.io/kubernetes/pause
docker tag f9d5de079539 gcr.io/google_containers/pause:2.0
 
这里相当于是把docker.io重命名为gcr.io，f9d5de079539为拉下来的镜像ID（docker images）
 
9) 确认K8S是否启动成功
kubectl get nodes
  
9 部署Nginx集群
1) 创建Nginx Pods
kubectl run nginx --image=nginx --port=80  --replicas=5
kubectl get pods
 
2) 创建nginx-service.yaml
复制代码
apiVersion: v1
kind: Service
metadata:
  name: nginx
  labels:
    app: nginx
spec:
  ports:
  - port: 80
    targetPort: 9090
  selector:
    name: nginx 
复制代码
3) 根据Pods创建Service
kubectl create -f nginx-service.yaml
kubectl get services
 
到此K8S集群部署完成。

11/3
hello：
今天，先把刚上传的FlexVolume的代码看了一下，代码本身还是能理解，只是其中的逻辑不是很清楚。
了解Attach，Detach，Mount，Unmount操作的过程,研究了一下aliyun-disk的相关代码
K8s flexVolume 的文档
感觉你可以动手试试在Ubuntu上安装K8S就可以了，Centos安装过程类似，而且开源这边平常用的不多。
另外有空的话也熟悉下Mesos的安装吧，据说Mesos目前支持CSI已经Ready，我们准备搭建一个Mesos的环境来对接OpenSDS。
